#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  claw,           sensorDigitalOut)
#pragma config(Sensor, dgtl2,  hangLock,       sensorDigitalOut)
#pragma config(Sensor, dgtl3,  liftBottom,     sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           driveLeftFront, tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           driveRightBack, tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           liftRightEnc,  tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port4,           liftLeftIn,    tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           liftRightTop,  tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           liftLeftTop,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           liftRightIn,   tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           liftLeftEnc,   tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port9,           driveLeftBack, tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          driveRightFront, tmotorVex393HighSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)


int releaseThreshold = 700; // needs to be set correctly later
int heightThreshold = 17;
int pickUpSpeed = 60;

//Competition Control and Duration Setting

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;






task liftHolder()
{

	while(1==1)
	{
			motor[liftLeftEnc] = motor[liftLeftIn] = motor[liftLeftTop] = motor[liftRightEnc] = motor[liftRightIn] = motor[liftRightTop] = heightThreshold;
			wait1Msec(50);
	}



}


// Functions Start Here //


//Clear Function//

void clearGyro()
{
	SensorValue(gyro) = 0;
}

void clearDrive()
{
	nMotorEncoder[driveLeftBack] = nMotorEncoder[driveRightBack] = 0;
	// I Guess this works...
}

void clearLift()
{
	nMotorEncoder[liftLeftEnc] = nMotorEncoder[liftRightEnc] = 0;
}

void clearAllEncoder()
{
	clearDrive();
	clearLift();
}

//Hault Function//

void haultDrive( int time )
{
	motor[driveRightFront] = 0;
	motor[driveRightBack] = 0;
	motor[driveLeftFront] = 0;
	motor[driveLeftBack] = 0;
	wait1Msec(time);
}

void haultLift( int time )
{
	motor[liftLeftEnc] = 0;
	motor[liftLeftIn] = 0;
	motor[liftLeftTop] = 0;
	motor[liftRightEnc] = 0;
	motor[liftRightIn] = 0;
	motor[liftRightTop] = 0;
	wait1Msec(time);
}

void haultAll(int time)
{
	haultDrive(time);
	haultLift(time);
}

//Piston Function//

void closeClaw()
{
	SensorValue(claw) = 1;
}

void openClaw()
{
	SensorValue(claw) = 0;
}

void lockHang()
{
	SensorValue(hangLock) = 0;
}

void unlockHang()
{
	SensorValue(hangLock) = 1;
}

#warning "is the pickup speed good?"
void pickUp()
{
	closeClaw();
	motor[liftLeftEnc] = motor[liftLeftIn] = motor[liftLeftTop] = motor[liftRightEnc] = motor[liftRightIn] = motor[liftRightTop] = pickUpSpeed;
}

//Drive Funnction//

void driveForwardPid(int Encoder)
{

	float kp = 0.001;
	float ki = 0.08;
	float kd = 0.01;

	int integral;
	int der;

	int error;
	int prevErr;

	int speed;

	int bias = 3;

	int minSpeed = 20;

	while(nMotorEncoder[driveRightBack] < Encoder || nMotorEncoder[driveLeftBack] < Encoder)
	{

		error = ((Encoder - nMotorEncoder[driveRightBack])+(Encoder - nMotorEncoder[driveLeftBack]))/2;


		if(error > 100)
		{
			integral = 0;
		}
		else
		{
			integral += error;
		}

		der = prevErr - error;
		prevErr = error;

		speed = ((int)(error*kp + integral*ki + der*kd) > minSpeed)?(int)(error*kp+integral*ki+der*kd):minSpeed;

#warning "Assuming Gyro Positive is Left Drift"

		if (SensorValue(gyro) > 10)

		{
			motor[driveRightFront] = speed;
			motor[driveRightBack] = speed;
			motor[driveLeftFront] = speed/bias;
			motor[driveLeftBack] = speed/bias;
		}
		else if (SensorValue(gyro) < 10)
		{
			motor[driveRightFront] = speed/bias;
			motor[driveRightBack] = speed/bias;
			motor[driveLeftFront] = speed;
			motor[driveLeftBack] = speed;
		}
		else
		{
			motor[driveRightFront] = speed;
			motor[driveRightBack] = speed;
			motor[driveLeftFront] = speed;
			motor[driveLeftBack] = speed;
		}
	}
}

void driveEnc(int speed, int Encoder)
{
	int bias = 3;
	while (nMotorEncoder[driveLeftBack] < Encoder || nMotorEncoder[driveRightBack] < Encoder)
	{
		if (SensorValue(gyro) > 10)
		{
			motor[driveRightFront] = speed;
			motor[driveRightBack] = speed;
			motor[driveLeftFront] = speed/bias;
			motor[driveLeftBack] = speed/bias;
		}
		else if (SensorValue(gyro) < 10)
		{
			motor[driveRightFront] = speed/bias;
			motor[driveRightBack] = speed/bias;
			motor[driveLeftFront] = speed;
			motor[driveLeftBack] = speed;
		}
		else
		{
			motor[driveRightFront] = speed;
			motor[driveRightBack] = speed;
			motor[driveLeftFront] = speed;
			motor[driveLeftBack] = speed;
		}
	}
}

void driveTime(int speed, int time)
{
	motor[driveRightFront] = speed;
	motor[driveRightBack] = speed;
	motor[driveLeftFront] = speed;
	motor[driveLeftBack] = speed;
	wait1Msec(time);
}


void drive(int rightSide, int leftSide, int time)
{
	motor[driveRightFront] = rightSide;
	motor[driveRightBack] = rightSide;
	motor[driveLeftFront] = leftSide;
	motor[driveLeftBack] = leftSide;
	wait1Msec(time);
}

void gyroTurn(int degrees, char direction)
{
	int dir = 1;

	if (direction == 'r' || direction == 'l')
		dir = -1;

	float kp = 0.001;
	float ki = 0.08;
	float kd = 0.01;

	int integral;
	int der;

	int error;
	int prevErr;

	int speed;

	int bias = 3;

	int minSpeed = 20;

	int stationaryCount = 0;
	bool targetReached = false;

	while(!targetReached)
	{

		error = degrees - SensorValue(gyro);


		if(error > 100)
		{
			integral = 0;
		}
		else
		{
			integral += error;
		}

		der = prevErr - error;
		prevErr = error;

		speed = ((int)(error*kp + integral*ki + der*kd) > minSpeed)?(int)(error*kp+integral*ki+der*kd):minSpeed;

		motor[driveRightFront] = -speed*dir;
		motor[driveRightBack] = -speed*dir;
		motor[driveLeftFront] = speed*dir;
		motor[driveLeftBack] = speed*dir;

		if(abs(error) < 10)
			stationaryCount++;
		else
			stationaryCount = 0;

		if(stationaryCount > 2000)
			targetReached = true;
	}
}

//Lift Function//

void liftTime(int speed, int time)
{
	motor[liftLeftEnc] = speed;
	motor[liftLeftIn] = speed;
	motor[liftLeftTop] = speed;
	motor[liftRightEnc] = speed;
	motor[liftRightIn] = speed;
	motor[liftRightTop] = speed;
	wait1Msec(time);
}

void liftEnc(int speed, int Enc)
{
	while(nMotorEncoder[liftLeftEnc] < Enc || nMotorEncoder[liftRightEnc] < Enc)
	{
		motor[liftLeftEnc] = speed;
		motor[liftLeftIn] = speed;
		motor[liftLeftTop] = speed;
		motor[liftRightEnc] = speed;
		motor[liftRightIn] = speed;
		motor[liftRightTop] = speed;
	}
}

void lift2Bottom()
{
	while(liftBottom != 1)
	{
		motor[liftLeftEnc] = -127;
		motor[liftLeftIn] = -127;
		motor[liftLeftTop] = -127;
		motor[liftRightEnc] = -127;
		motor[liftRightIn] = -127;
		motor[liftRightTop] = -127;
	}
	clearLift();
}

//Game Specific//

void score(int distance)
{
	while((nMotorEncoder[liftLeftEnc] < releaseThreshold || nMotorEncoder[liftRightEnc] < releaseThreshold )
		&& (nMotorEncoder[driveLeftBack] <distance|| nMotorEncoder[driveRightBack] < distance))
	{
		if(nMotorEncoder[liftLeftEnc] < releaseThreshold || nMotorEncoder[liftRightEnc] < releaseThreshold)
		{
			motor[liftLeftEnc] = 127;
			motor[liftLeftIn] = 127;
			motor[liftLeftTop] = 127;
			motor[liftRightEnc] = 127;
			motor[liftRightIn] = 127;
			motor[liftRightTop] = 127;
		}
		else
		{
			openClaw();
			motor[liftLeftEnc] = 0;
			motor[liftLeftIn] = 0;
			motor[liftLeftTop] = 0;
			motor[liftRightEnc] = 0;
			motor[liftRightIn] = 0;
			motor[liftRightTop] = 0;
		}
		if(nMotorEncoder[driveLeftBack] <distance|| nMotorEncoder[driveRightBack] < distance)
		{
			motor[driveRightFront] = -127;
			motor[driveRightBack] = -127;
			motor[driveLeftFront] = -127;
			motor[driveLeftBack] = -127;
		}
		else
		{
			motor[driveRightFront] = 0;
			motor[driveRightBack] = 0;
			motor[driveLeftFront] = 0;
			motor[driveLeftBack] = 0;
		}
	}
}

void hangFromGround()
{
	motor[driveRightFront] = 127;
	motor[driveRightBack] = 127;
	motor[driveLeftFront] = 127;
	motor[driveLeftBack] = 127;
	wait1Msec(1000);

	while(liftBottom != 1)
	{
		motor[liftLeftEnc] = 127;
		motor[liftLeftIn] = 127;
		motor[liftLeftTop] = 127;
		motor[liftRightEnc] = 127;
		motor[liftRightIn] = 127;
		motor[liftRightTop] = 127;
	}

	lockHang();



}

// Functions End//


//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------
int count = 0;
void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	// bStopTasksBetweenModes = true;
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Declare count variable to keep track of our choice

	//Loop while center button is not pressed
	bool auton = false;

#warning "true is diabled    false is enabled check this tmmr"

	while(!auton)
	{
		if(bIfiRobotDisabled || !bIfiAutonomousMode) // true is diabled false is enabled check this tmmr
		{
			//Switch case that allows the user to choose from 4 different options
			switch(count){
			case 0:
				//Display first choice
				displayLCDCenteredString(0, "Game  ||  Skills");
				displayLCDCenteredString(1, "   Team 3050A   ");
				waitForPress();
				//Increment or decrement "count" based on button press
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count = 1;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count = 100;
				}
				break;
			case 100:
				//Display second choice
				displayLCDCenteredString(0, "  Enter Skills? ");
				displayLCDCenteredString(1, "Enter Back Enter");
				waitForPress();
				//Increment or decrement "count" based on button press
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count = 0;
					auton = true;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count = 0;
					auton = true;

				}
				else if (nLCDButtons == centerButton)
				{
					waitForRelease();
					count = 0;

				}
				break;
			case 1:
				//Display third choice
				displayLCDCenteredString(0, "    Auton 1    ");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				//Increment or decrement "count" based on button press
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count--;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count++;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					auton = true;
				}
				break;
			case 2:
				//Display fourth choice
				displayLCDCenteredString(0, "    Auton 2     ");
				displayLCDCenteredString(1, "<     Enter    >");
				waitForPress();
				//Increment or decrement "count" based on button press
				if(nLCDButtons == leftButton)
				{
					waitForRelease();
					count--;
				}
				else if(nLCDButtons == rightButton)
				{
					waitForRelease();
					count = 0;
				}
				else if(nLCDButtons == centerButton)
				{
					waitForRelease();
					auton = true;
				}
				break;
			default:
				count = 0;
				break;

			}
		}
		else
		{
			auton = true;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Prog Skills");
		displayLCDCenteredString(1, "is running!");




		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Autonomous 1");
		displayLCDCenteredString(1, "is running!");

		openClaw();
		liftEnc(127, 400);
		haultLift(10);
		lift2Bottom();
		haultAll(100);

		driveForwardPid(2000);
		haultDrive(10);
		pickUp();
		startTask(liftHolder);

		drive(-127, -50, 1000);
		haultDrive(10);

		gyroTurn(500, 'l');
		haultDrive(10);
		clearGyro();

		stopTask(liftHolder);

		score(600);
		haultAll(100);

		lift2Bottom();

		drive(-127, -127, 500);
		haultDrive(10);

		gyroTurn(500, 'r')
		haultDrive(10);

		driveForwardPid(1000);
		haultDrive(10);
		pickUp();

		startTask(liftHolder);

		gyroTurn(500, 'l');
		haultDrive(10);

		driveEnc(200, 127)
		haultDrive(10);

		stopTask(liftHolder);

		score(500);
		haultAll(10);


		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "Autonomous 2");
		displayLCDCenteredString(1, "is running!");

		break;

	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{

	bLCDBacklight = true;									// Turn on LCD Backlight
	string mainBattery, backupBattery;

	while (true)
	{

		clearLCDLine(0);											// Clear line 1 (0) of the LCD
		clearLCDLine(1);											// Clear line 2 (1) of the LCD

		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayNextLCDString(mainBattery);

		//Display the Backup battery voltage
		displayLCDString(1, 0, "Backup: ");
		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');	//Build the value to be displayed
		displayNextLCDString(backupBattery);

		wait1Msec(10);

		motor[driveRightFront] = vexRT[Ch2];
		motor[driveRightBack] = vexRT[Ch2];
		motor[driveLeftFront] = vexRT[Ch3];
		motor[driveLeftBack] = vexRT[Ch3];


		if(vexRT[Btn6D] == 1)
			SensorValue(hangLock) = 0;
		else if(vexRT[Btn6U] == 1)
			SensorValue(hangLock) = 1;
		else if(vexRT(Btn7U) == 1)
			hangFromGround();


		if(vexRT[Btn5D] == 1 || nMotorEncoder[liftRightEnc] > releaseThreshold)
		{
			openClaw();
		}
		else if (vexRT[Btn5U] == 1)
		{
			closeClaw();
		}

		if(vexRT[Btn6U] == 1)
		{
			closeClaw();
			motor[liftLeftEnc] = 127;
			motor[liftLeftIn] = 127;
			motor[liftLeftTop] = 127;
			motor[liftRightEnc] = 127;
			motor[liftRightIn] = 127;
			motor[liftRightTop] = 127;
		}
		else if(vexRT[Btn6D] == 1)
		{
			motor[liftLeftEnc] = -127;
			motor[liftLeftIn] = -127;
			motor[liftLeftTop] = -127;
			motor[liftRightEnc] = -127;
			motor[liftRightIn] = -127;
			motor[liftRightTop] = -127;
		}

		else
		{
			motor[liftLeftEnc] = heightThreshold;
			motor[liftLeftIn] = heightThreshold;
			motor[liftLeftTop] = heightThreshold;
			motor[liftRightEnc] = heightThreshold;
			motor[liftRightIn] = heightThreshold;
			motor[liftRightTop] = heightThreshold;
		}
	}
}
